##Introduction
The Snails language can be used for pattern matching on two-dimensional grids of characters. For concision, the instructions are generally one character. The mode of operation is somewhat similar to a regex, although with a more imperative flavor: the interpreter tries various alternatives and backtracks from dead ends until a match is found. 

The input grid is constructed by reading the input file, removing one trailing newline if it exists, splitting on newlines, and putting each of the resulting strings on a separate row. The grid's width is equal to the length of the longest line, and the height equal to the number of lines. However, when one of these is 0, the grid will behave as 1x1 for some purposes.

The output of a program which runs without error is a single nonnegative integer, which reflects the number of times or whether a match was found.


##Instructions

###Matching characters
The following instructions match exactly one character/grid location. If the snail has not moved since the beginning of the pattern or a teleport, the match location is the snail's current location. Otherwise, it is the cell at the current location + the direction vector. If the match succeeds, the snail's location is set to the match location and the cell of the match location is considered to be covered in slime. A cell covered in slime cannot be matched again.

 - `\`<char> matches exactly <char>.
 - `~` matches an out-of-bounds cell
 - `.` matches any character (but not out-of-bounds)
 - `^`<char> matches any character but <char> (but not out-of-bounds)


###Directions
The following commands set the direction of the snail:

 - `u` up
 - `d` down
 - `l` left
 - `r` right
 - `o` orthogonal directions (up, down, left, or right)
 - `y` any of 4 diagonal directions
 - `z` orthonal or diagonal (8 ways)
 - `s` zero directional vector (not sure why I made this one)
 - `c` 90 degrees clockwise relative to current direction
 - `w` 90 degrees counterclockwise relative to current direction
 - `f` forward (current direction)
 - `b` backward (180 degrees relative to current direction)
 - `n` 90 degrees either clockwise or counterclockwise from current direction
 - `a`[*n*] sets a direction 45*n* degrees counterclockwise from due east. *n* is the value of the following character if it is a digit, else 1. E.g. `a3` = northwest.
 - `e`[*n*] sets a direction 45*n* degrees counterclockwise relative to the current direction. *n* is the value of the following character if it is a digit, else 1.

If multiple direction instructions are found in consecutive characters, they are treated as an alternation. For example `lr` is equivalent to `(l|r)`. When the same direction vector is generated by more than one instruction (such as when the snail is traveling upward and `lw` occurs), then subsequent pattern is executed with that direction vector only once.

###Quantifiers

 - <atom>`+` matches the pattern <atom> 1 or more times
 - <atom>*[m]*`,`*[n]* matches the pattern <atom> at least *m* (default 0) and at most *n* (default infinity) times
 - <atom>`?` matches the pattern <atom> 0 or 1 times
 - <atom>*n* matches the pattern <atom> exactly *n* times

###Grouping
Matching pairs of parentheses `()` or curly braces `{}` will behave as expected (like parentheses in regex), but it is also possible to leave out one half of a pair and have it inferred, according to the following rules. `)` or `}` groups everything to the left until the nearest unclosed group opening instruction of the same type(`(` or `{` respectively), or the beginning of the pattern if none exists. It closes any unclosed opening instructions of the opposite type in the middle of this range. An otherwise unmatched `(` or `{` is closed by the end of the pattern.

The `` ` `` instruction groups everything to the left until the nearest unclosed group opening instruction, alternator `|`, or the beginning of the pattern.

Examples of equivalent ways to group instructions:

- `a(b}c` <-> `{a(b)}c`
- `a(b}c)d` <-> `({a(b)}c)d`
- ``(a{b}c\`d`` <-> `((a{b}c)d)`
- ``a{b|cd\`e\`f}`` <-> `a{b|((cd)e)f}`


###Assertions
The pattern in an assertion must match (positive) or not match (negative) for the overall pattern to succeed, but does not alter the current state (position, slime, etc.). Like `(?=...)` or `(?!...)` in regex.

- `=`<atom> The pattern <atom> must match from the current state.
- `!`<atom> The pattern <atom> must not match from the current state.

###Comments
`,,` begins a comment that continues to the end of the line, with the exception of when the first comma is being used literally (e.g. `^,`).

### Options
If the program contains at least one newline, the first line is interpreted from the following list of options:

#### Match mode options

 - <none> The default mode is to try the pattern starting from each cell of the input grid with each starting direction and count the number of times the match succeeds.
 - `?` If the match suceeds at least once prints `1`, otherwise `0`.
 - `&` Prints `1` if the match succeeds at every starting position/direction, otherwise `0`.
 - `A` Counts all accepting paths through the pattern.

####Starting position options
 - `^` Starts only in the top left corner, rather than anywhere on the grid.
 - `udlroyzsa` A list of absolute directions - changes the starting directions to those, instead of the default of only right.
 - `M` Skips matching the starting cell. The first character matched will be the one in the starting direction.

####Miscellaneous options
 - `E` Replaces any cells within the input grid that don't have a character on them (due to ragged lines) with the character after `E`.
 - `F` Same as `E` with an argument of <space>.
 - `R` Given lines of unequal lengths, constructs the input grid by right-justifying them, rather than the default of left-justifying.

###Operator precedence
The operators are parsed according to the following precedence order, from highest to lowest.

1. Inside of parenthesis- or curly brace-delimited groups: `(...)` `{...}`
2. Parts of an alternation: `...|...`
3. Backtick-delimited groups: `...\``
4. Quantifiers `<n>` `+` `?` `[m],[n]`
5. Assertions `!` `=`
6. Juxtaposition
